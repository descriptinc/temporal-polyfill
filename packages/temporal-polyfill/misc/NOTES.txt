
complicated internal property access
------------------------------------
failing because we need to bypass constructor when creating internal instances,
to avoid re-parsing input. technique:
https://github.com/js-temporal/temporal-polyfill/blob/main/lib/ecmascript.ts#L1826-L1827



TODO: move to global builtin casts!!!!

now = Temporal.PlainDate.from('2022-01-01')
then = Temporal.PlainDate.from('2023-12-25')

duration = now.until(then, { largestUnit: 'year', smallestUnit: 'month', roundingMode: 'ceil' })
console.log(duration.toString())

roundedDuration = duration.round({ relativeTo: now, largestUnit: 'year', smallestUnit: 'month', roundingMode: 'ceil' })
console.log(roundedDuration.toString())



now = Temporal.PlainDate.from('2022-01-01')
then = Temporal.PlainDate.from('2023-12-25')
now.until(then, { largestUnit: 'year', smallestUnit: 'month', roundingIncrement: 3 })
#
# ^^^ this actually does work
#

now = Temporal.PlainDate.from('2022-01-01')
then = Temporal.PlainDate.from('2023-12-25')
now.until(then, { largestUnit: 'month', smallestUnit: 'day', roundingIncrement: 3 })
#
# ^^^ works too
#

#
# our bug with diffing Februaries
# correct behavior (direction matters):
#
Temporal.PlainDate.from('2022-01-31').until('2022-02-28', { largestUnit: 'year' }).toString()
-> 'P1M'
Temporal.PlainDate.from('2022-02-28').until('2022-01-31', { largestUnit: 'year' }).toString()
-> '-P28D'
Temporal.PlainDate.from('2022-03-31').until('2022-02-28', { largestUnit: 'year' }).toString()
-> '-P1M'



The following tests took a long time:
  timezone:
    133 ms: test262/test/intl402/Temporal/TimeZone/prototype/getPlainDateTimeFor/basic.js
    188 ms: test262/test/staging/Temporal/ZonedDateTime/old/dst-math.js
  duration rounding:
    115 ms: test262/test/staging/Temporal/Duration/old/round.js


The roundingMode option controls how the rounding is performed:
- ceil, expand: Always round up, towards 23:59:59.999999999.
- floor, trunc: Always round down, towards 00:00.
- halfCeil, halfExpand: Round to the nearest of the values allowed by roundingIncrement and smallestUnit. When there is a tie, round up, like ceil.
- halfFloor, halfTrunc: Round to the nearest of the allowed values, like halfExpand, but when there is a tie, round down, like floor.
- halfEven: Round to the nearest of the allowed values, but when there is a tie, round towards the value that is an even multiple of roundingIncrement. For example, with a roundingIncrement of 2, the number 7 would round up to 8 instead of down to 6, because 8 is an even multiple of 2 (2 × 4 = 8, and 4 is even), whereas 6 is an odd multiple (2 × 3 = 6, and 3 is odd).

https://github.com/tc39/proposal-temporal/blob/84d1b184ac200a81a6648f2d148082f69ae0547b/polyfill/lib/ecmascript.mjs#L4492

function RoundNumberToIncrement(quantity, increment, mode) {
    if (increment === 1) return quantity;
    let quotient = Math.floor(quantity / increment);
    let remainder = quantity % increment;
    if (remainder === 0) return quantity;
    const sign = remainder < 0 ? -1 : 1;
    const tiebreaker = Math.abs(remainder) * 2;
    const tie = tiebreaker === increment;
    const expandIsNearer = tiebreaker > increment;
    switch (mode) {
      case 'ceil':
        if (sign > 0) quotient += sign;
        break;
      case 'floor':
        if (sign < 0) quotient += sign;
        break;
      case 'expand':
        // always expand if there is a remainder
        quotient += sign;
        break;
      case 'trunc':
        // no change needed, because divmod is a truncation
        break;
      case 'halfCeil':
        if (expandIsNearer || (tie && sign > 0)) quotient += sign;
        break;
      case 'halfFloor':
        if (expandIsNearer || (tie && sign < 0)) quotient += sign;
        break;
      case 'halfExpand':
        // "half up away from zero"
        if (expandIsNearer || tie) quotient += sign;
        break;
      case 'halfTrunc':
        if (expandIsNearer) quotient += sign;
        break;
      case 'halfEven':
        if (expandIsNearer || (tie && quotient % 2 === 1)) quotient += sign;
        break;
    }
    return quotient * increment;
}
