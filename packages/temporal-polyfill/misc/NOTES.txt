
Internal Access
---------------

Calendar::from
  "has outer.calendar"
  "get outer.calendar"
  "has inner.calendar"
  "get inner.toString"
  "call inner.toString"

  ToTemporalCalendar: (calendarLike) => {
    if (ES.Type(calendarLike) === 'Object') {
      if (ES.IsTemporalCalendar(calendarLike)) {
        return calendarLike; // fast optimization
      }
      if (HasSlot(calendarLike, CALENDAR)) {
        return GetSlot(calendarLike, CALENDAR); // optimization avoids calling .calendar!
      }
      if (ES.IsTemporalTimeZone(calendarLike)) {
        throw new RangeError('Expected a calendar object but received a Temporal.TimeZone');
      }
      if ('calendar' NOT-IN calendarLike)) {
        return calendarLike; // assume object is a CalendarProtocol
      }

      // assume object is datetime-like (but less formal b/c doesnt have slot)...
      calendarLike = calendarLike.calendar;

      // same object-parsing as above but without optimizations
      if (ES.Type(calendarLike) === 'Object') {
        if (ES.IsTemporalTimeZone(calendarLike)) {
          throw new RangeError('Expected a calendar object as the calendar property but received a Temporal.TimeZone');
        }
        if ('calendar' NOT-IN calendarLike) {
          return calendarLike;
        }
      }
    }
    // string parsing of calendarLike...
  }


TypeError vs RangeError
-----------------------

Temporal.Calendar.from DOCS
  - If the value is another Temporal.Calendar object,
    or object implementing the calendar protocol,
    the same object is returned
  - If the value is another Temporal object that carries a calendar or an object with a calendar
    property, such as a Temporal.ZonedDateTime, the object's calendar is returned
  - Any other value is converted to a string

Calendar::from (accepts ID or object with calendar property)
  assert.throws(RangeError, () => Temporal.Calendar.from({ calendar: "local" }));
    --- invalid ISO 8601 string: local
  assert.throws(RangeError, () => Temporal.Calendar.from({ calendar: { calendar: "iso8601" } }));
    --- invalid ISO 8601 string: [object Object] --- way too nested
  RangeError (as well as within { calendar: <thing> })
    null
    true
    ""
    1
    1n
    new Temporal.TimeZone("UTC") --- explicitly disallowed
  TypeError (as well as within { calendar: <thing> })
    Symbol

OVERFLOW/DISAMBIGUATION options
  RangeError (all below convert to strings)
    null
    true
    false
    2
    2n
    {}
  TypeError
    Symbol

PlainDate::from (accepts bag)
  RangeError
    undefined
    null
    true
    ""
    1
    1n
  TypeError
    Symbol()
    {} --- required property 'day' missing or undefined
    Temporal.PlainDate - a "function" --- same
    Temporal.PlainDate.prototype --- invalid receiver (brand check)

PlainDateTime::from (accepts bag)
  RangeError
    undefined
    null
    true
    ""
    5
    5n
  TypeError
    Symbol()
    { year: 2020 } --- required property 'day' missing or undefined

Instant::from
  RangeError
    undefined
    null
    true
    "",
    1
    19761118
    1n
    {}, --- invalid ISO 8601 string: [object Object]
    Temporal.Instant
  TypeError
    Symbol
    Temporal.Instant.prototype --- will throw TypeError on toString b/c of branding

TimeZone::from
  RangeError
    undefined,
    null,
    true,
    "string",
    "local",
    "Z",
    "-00:00[UTC]",
    "+00:01.1",
    "-01.1",
    "1994-11-05T08:15:30+25:00",
    "1994-11-05T13:15:30-25:00",
    7,
    4.2,
    12n,
  TypeError
    Symbol()
  Success
    {} --- just returns the object itself


parsing
-------

smarter non-regexp parser
parse arbitrary ending [matter]


TimeZone::getOffsetNanosecondsFor laziness/incorrectness
--------------------------------------------------------

*-not-callable fix is easy
  make sure getOffsetNanosecondsFor is callable first, otherwise throw TypeError
  seems like we're not calling at all

*-wrong-type fix is easy
  ensure what's returned from getOffsetNanosecondsFor is legit

what!?
  class TZ extends Temporal.TimeZone {
    constructor() { super("UTC") }
    getOffsetNanosecondsFor(arg) {
      console.log('CALLED IT!')
      return super.getOffsetNanosecondsFor(arg)
    }
  }
  d = new Temporal.ZonedDateTime(0n, new TZ())

  // js-temporal polyfill calls getOffsetNanosecondsFor twice!!!
